#include "classfile/symbolTable.hpp"
#include "classfile/systemDictionary.hpp"
#include "compiler/compileBroker.hpp"
#include "oops/method.hpp"
#include "oops/typeArrayKlass.hpp"
#include "runtime/arguments.hpp"
#include "runtime/fieldType.hpp"
#include "runtime/javaCalls.hpp"
#include "runtime/mutexLocker.hpp"
#include "runtime/os.hpp"
#include "runtime/thread.hpp"
#include "runtime/vm_operations.hpp"
#include "utilities/hashtable.inline.hpp"
#include "utilities/stack.hpp"
#include "runtime/atomic.hpp"
#include "runtime/feedbackDirectOpt.hpp"

// Masks for compile policies
#define USE_LOW_THRESHOLD             (1U << (Deoptimization::Reason_LIMIT + 1))
#define DEOPT_NULL_CHECK              (1U << Deoptimization::Reason_null_check)
#define DEOPT_NULL_ASSERT             (1U << Deoptimization::Reason_null_assert)
#define DEOPT_RANGE_CHECK             (1U << Deoptimization::Reason_range_check)
#define DEOPT_CLASS_CHECK             (1U << Deoptimization::Reason_class_check)
#define DEOPT_ARRAY_CHECK             (1U << Deoptimization::Reason_array_check)
#define DEOPT_INTRINSIC               (1U << Deoptimization::Reason_intrinsic)
#define DEOPT_BIMORPHIC               (1U << Deoptimization::Reason_bimorphic)
#define DEOPT_UNLOADED                (1U << Deoptimization::Reason_unloaded)
#define DEOPT_UNINITIALIZED           (1U << Deoptimization::Reason_uninitialized)
#define DEOPT_UNREACHED               (1U << Deoptimization::Reason_unreached)
#define DEOPT_UNHANDLED               (1U << Deoptimization::Reason_unhandled)
#define DEOPT_CONSTRAINT              (1U << Deoptimization::Reason_constraint)
#define DEOPT_DIV0_CHECK              (1U << Deoptimization::Reason_div0_check)
#define DEOPT_AGE                     (1U << Deoptimization::Reason_age)
#define DEOPT_PREDICATE               (1U << Deoptimization::Reason_predicate)
#define DEOPT_LOOP_LIMIT_CHECK        (1U << Deoptimization::Reason_loop_limit_check)
#define DEOPT_SPECULATE_CLASS_CHECK   (1U << Deoptimization::Reason_speculate_class_check)
#define DEOPT_RTM_STATE_CHANGE        (1U << Deoptimization::Reason_rtm_state_change)
#define DEOPT_UNSTABLE_IF             (1U << Deoptimization::Reason_unstable_if)

#define COMPILE_POLICY_CLASS_START "FDOPolicy"
#define LOW_THRESHOLD_STR "low_threshold"
#define ENTRY_NUMBER "EntryNumber"
#define MAX_POLICY_NUM 0x7fffffff/10
#define POLICY_LINE_START "    "
#define CLASS_LINE_START "  "
#define FDO_DICT_SIZE 8192
#define FDO_ENTRY_SIZE 1024

FDOCompilation* FDOCompilation::_instance = NULL;
FDOCompilation::FDOCompilation()
  : _dict(NULL) {
  assert(Deoptimization::Reason_LIMIT <= 31, "Policy bits overflow");
}
FDOCompilation::~FDOCompilation() {
  delete _dict;
  delete _instance;
}

void FDOCompilation::create_instance() {
  if (_instance == NULL) {
    _instance = new FDOCompilation();
    _instance->_dict = new FDOPolicyDictionary(FDO_DICT_SIZE);
    _instance->_dict->load_policy();
  }
}

unsigned int FDOPolicyDictionary::get_policy_bits(Method* method) {
  InstanceKlass* klass = method->constants()->pool_holder();
  char* class_loader_name = NULL;
  Handle class_loader(Thread::current(), klass->class_loader());
  if (!oopDesc::is_null(class_loader())) {
    class_loader_name = class_loader()->klass()->name()->as_C_string();
  } else {
    class_loader_name = (char*)DEFAULT_CLASSLOADER;
  }
  Symbol* classloader = SymbolTable::new_symbol(class_loader_name, strlen(class_loader_name), Thread::current());
  Symbol* class_name = klass->name();
  char* file_path_name = NULL;
  if (klass->source_file_path()) {
    file_path_name = klass->source_file_path()->as_C_string();
  } else {
    file_path_name = (char*)DEFAULT_FILEPATH;
  }
  Symbol* file_path = SymbolTable::new_symbol(file_path_name, strlen(file_path_name), Thread::current());
  Symbol* method_name = method->name();
  Symbol* signature = method->signature();
  unsigned int hash = compute_hash(class_name);
  FDOPolicyEntry* entry = find_entry(hash, classloader, class_name, file_path, method_name, signature);
  if (entry) {
    return entry->literal()->policy();
  } else {
    return 0;
  }
}

// Target method will use lower compile threshold
bool FDOCompilation::compile_with_low_threshold(Method* method, int mdo_i, int mdo_b) {
  FDOPolicyDictionary* dict = FDOCompilation::instance()->dict();
  bool result = false;
  if (dict != NULL) {
    int policy = dict->get_policy_bits(method);
    if (policy & USE_LOW_THRESHOLD) {
      if (((mdo_i + mdo_b) > FDOCompileThreshold) && mdo_i >= Tier4MinInvocationThreshold) {
        result = true;
      } else if (mdo_i > FDOInvocationThreshold) {
        result = true;
      }
    }
  }
  return result;
}

// This function determines whether uncommon trap for input reason should be added.
bool FDOCompilation::seen_feedback_deopt(unsigned int deopt_bits, Deoptimization::DeoptReason reason) {
  // Unstable_if trap will not be added if
  // 1. This method has recorded unstable if deopt.
  // 2. This method is compiled in low threshold.
  if (deopt_bits & (1U << reason)) {
    return true;
  }
  return false;
}

FDOPolicy::FDOPolicy(Symbol* classloader_name, Symbol* class_name, Symbol* filepath_name, Symbol* method_name, Symbol* signature) {
  _class_name = class_name;
  _classloader_name = classloader_name;
  _filepath_name = filepath_name;
  _method_name = method_name;
  _signature = signature;
  _policy = 0u;
}
FDOPolicy::~FDOPolicy() {
}
Symbol* const FDOPolicy::class_name() {
  return _class_name;
}
Symbol* const FDOPolicy::classloader_name() {
  return _classloader_name;
}
Symbol* const FDOPolicy::filepath_name() {
  return _filepath_name;
}
Symbol* const FDOPolicy::method_name() {
  return _method_name;
}
Symbol* const FDOPolicy::signature() {
  return _signature;
}

// Two policies are matched only if the 5 aspects are all matched.
bool FDOPolicy::match(Symbol* classloader, Symbol* class_to_match, Symbol* filepath, Symbol* method, Symbol* sig) {
  if (class_name()->fast_compare(class_to_match) != 0) {
    return false;
  }
  if (classloader_name()->fast_compare(classloader) != 0) {
    return false;
  }
  if (filepath_name()->fast_compare(filepath) != 0) {
    return false;
  }
  if (method_name()->fast_compare(method) != 0) {
    return false;
  }
  if (signature()->fast_compare(sig) != 0) {
    return false;
  }
  return true;
}

bool FDOPolicy::match(FDOPolicy* policy) {
  return match(policy->classloader_name(), policy->class_name(), policy->filepath_name(), policy->method_name(), policy->signature());
}


void FDOPolicy::update_policy(unsigned int new_policy) {
  _policy = new_policy;
}

int FDOPolicyDictionary::read_field(char tmp[], char line[], int i, int length) {
  for (int j = i; i < (length - 2); i++) {
    if (line[i] == '\n' || line[i] == '\0') {
      tmp[i - j] = '\0';
      i = -1;
      break;
    } else if (line[i] != ' ') {
      tmp[i - j] = line[i];
    } else if (line[i] == ' ') {
      tmp[i -j] = '\0';
      break;
    }
  }
  for (; i < (length - 2); i++) {
    if (line[i] != ' ') break;
  }
  return i;
}

unsigned int FDOPolicyDictionary::parse_policy(char tmp[]) {
  unsigned int policy = 0;
  int reason = (int)Deoptimization::Reason_none;
  if (strcmp(tmp, LOW_THRESHOLD_STR) == 0) {
    return policy | USE_LOW_THRESHOLD;
  }
  for (; reason < (int)Deoptimization::Reason_LIMIT; reason++) {
    if (strcmp(tmp, Deoptimization::trap_reason_name(reason)) == 0) {
      policy |= 1U << reason;
      break;
    }
  }
  return policy;
}

bool FDOPolicyDictionary::find_entry_num(char line[]) {
  return (line == strstr(line, ENTRY_NUMBER));
}

int FDOPolicyDictionary::read_num(char line[], bool* valid, int max_length) {
  int recorded_num = 0;
  if (find_entry_num(line)) {
    int i = sizeof(ENTRY_NUMBER);
    while ((line[i] >= '0') && (line[i] <= '9')) {
      recorded_num = recorded_num * 10 + (int)(line[i] - '0');
      if ((i >= (max_length - 2)) || (recorded_num >= MAX_POLICY_NUM)) {
        *valid = false;
        if (PrintFDOErrorInfo) {
          tty->print_cr("FDO: Read policy number failed! The line number is %d", recorded_num);
        }
        break;
      } else {
        i++;
      }
    }
    if (PrintFDODetails) {
      tty->print_cr("FDO: Recorded policy number is %d", recorded_num);
    }
    if (recorded_num == 0) *valid = false;
  } else {
    *valid = false;
    if (PrintFDOErrorInfo) {
      tty->print_cr("FDO: Read failed! The file is not started with %s", ENTRY_NUMBER);
    }
  }
  return recorded_num;
}

bool FDOPolicyDictionary::is_policy_line(char line[]) {
  return line == strstr(line, POLICY_LINE_START);
}
bool FDOPolicyDictionary::is_class_line(char line[]) {
  return line == strstr(line, CLASS_LINE_START);
}
bool FDOPolicyDictionary::is_class_end(char line[]) {
  int i = sizeof(CLASS_LINE_START) - 1;
  return line[i] == '}';
}
bool FDOPolicyDictionary::is_classloader_end(char line[]) {
  return line[0] == '}';
}
Symbol* FDOPolicyDictionary::read_classloader(char line[], char tmp[], bool* valid, int max_length) {
   int i = 0;
   for (; i < (max_length - 2); i++) {
     if (line[i] == '\n' || line[i] == '\0') {
       *valid = false;
       if (PrintFDOErrorInfo) {
         tty->print_cr("FDO: missing { in classloader line");
       }
       break;
     } else if (line[i] == ' ') {
       // end of classloader
       break;
     } else {
       tmp[i] = line[i];
     }
   }
   if (i == (max_length - 2)) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: This line is too long");
     }
   }
   tmp[i] = '\0';
   Symbol* classloader_symbol = NULL;
   if (*valid) {
     classloader_symbol = SymbolTable::new_symbol(tmp, strlen(tmp), Thread::current());
     if (PrintFDODetails) {
       tty->print_cr("FDO: Loaded classloader %s", classloader_symbol->as_C_string());
     }
   }
   return classloader_symbol;
}
unsigned int FDOPolicyDictionary::read_policy(Symbol** method_name,
     Symbol** signature, char line[], char tmp[], bool* valid, int max_length) {
   int i = 0;
   unsigned int measure = 0;
   for (; i < (max_length - 2); i++) {
     if (line[i] != ' ') break;
   }
   i = read_field(tmp, line, i, max_length);
   if ((i == -1) || (i > (max_length - 2))) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: Policy field is illegal %s %d", tmp, i);
     }
   }
   if (*valid) {
     measure = parse_policy(tmp);
   } else {
     *method_name = NULL;
     *signature = NULL;
     return 0 ;
   }
   // skip spaces
   for (; i < (max_length - 2); i++) {
     if (line[i] != ' ') break;
   }
   i = read_field(tmp, line, i, max_length);
   if ((i == -1) || (i > (max_length - 2))) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: Method field is illegal %s %d", tmp, i);
     }
   }
   if (*valid) {
     *method_name = SymbolTable::new_symbol(tmp, strlen(tmp), Thread::current());
   } else {
     *method_name = NULL;
     *signature = NULL;
     return 0;
   }
   // skip spaces
   for (; i < (max_length - 2); i++) {
     if (line[i] != ' ') break;
   }
   i = read_field(tmp, line, i, max_length);
   if (i > (max_length - 2)) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: Signature field is illegal %s %d", tmp, i);
     }
   }
   if (*valid) {
     *signature = SymbolTable::new_symbol(tmp, strlen(tmp), Thread::current());
     if (PrintFDODetails) {
       tty->print_cr("FDO: Loaded policy %d %s %s", measure, (*method_name)->as_C_string(), (*signature)->as_C_string());
     }

   } else {
     *method_name = NULL;
     *signature = NULL;
     return 0;
   }
   return measure;
}

void FDOPolicyDictionary::read_class(Symbol** class_name, Symbol** file_path,
                                char line[], char tmp[], bool* valid, int max_length) {
   int i = 0;
   for (; i < (max_length - 2); i++) {
     if (line[i] != ' ') break;
   }
   i = read_field(tmp, line, i, max_length);
   if ((i == -1) || (i > (max_length - 2))) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: CLass field is illegal %s %d", tmp, i);
     }
   }
   if (*valid) {
     *class_name = SymbolTable::new_symbol(tmp, strlen(tmp), Thread::current());
   } else {
     *class_name = NULL;
     *file_path = NULL;
     return;
   }
   // skip spaces
   for (; i < (max_length - 2); i++) {
     if (line[i] != ' ') break;
   }
   i = read_field(tmp, line, i, max_length);
   if ((i == -1) || (i > (max_length - 2))) {
     *valid = false;
     if (PrintFDOErrorInfo) {
       tty->print_cr("FDO: file path field is illegal");
     }
   }
   if (*valid) {
     *file_path = SymbolTable::new_symbol(tmp, strlen(tmp), Thread::current());
     if (PrintFDODetails) {
       tty->print_cr("FDO: Loaded class %s %s", (*class_name)->as_C_string(), (*file_path)->as_C_string());
     }
   } else {
     *class_name = NULL;
     *file_path = NULL;
   }
   return;
}


// FDOPolicyFile is generated by JFR.
// Its content is:
// EntryNumber xxx
// $CLassLoader {
//   $Class $FilePath {
//     $policy $method $signature
//     $policy $method $signature
//     $policy $method $signature
//     ...
//   }
// }
void FDOPolicyDictionary::load_policy() {
  if (FDOPolicyFile == NULL) return;
  FILE* f = NULL;
  if ((f = fopen(FDOPolicyFile, "r")) != NULL) {
    int num = 0;
    char line[FDO_ENTRY_SIZE];
    char tmp[FDO_ENTRY_SIZE];
    Symbol* class_symbol = NULL;
    Symbol* classloader_symbol = NULL;
    Symbol* filepath_symbol = NULL;
    Symbol* method_symbol = NULL;
    Symbol* signature_symbol = NULL;
    Symbol* policy_symbol = NULL;
    bool valid, end;
    int max_length = FDO_ENTRY_SIZE;
    int valid_num = 0;
    int recorded_num = 0;
    while (fgets(line, sizeof(line), f) != NULL) {
      valid = true;
      end = false;
      // First line of this policy file, should be
      // EntryNumber xxx
      // xxx is the number of policies recorded in this file.
      if (recorded_num == 0) {
        recorded_num = read_num(line, &valid, max_length);
      } else {
        int i = 0, j = 0, k = 0;
        if (is_policy_line(line)) {
          if ((classloader_symbol == NULL) || (class_symbol == NULL) || (filepath_symbol == NULL)){
            valid = false;
            if (PrintFDOErrorInfo) {
              tty->print_cr("FDO: Precondition of policy is wrong %p %p %p", classloader_symbol, class_symbol, filepath_symbol);
            }
          } else {
            unsigned int compile_measure = read_policy(&method_symbol, &signature_symbol, line, tmp, &valid, max_length);
            if (valid) {
              add_policy(compile_measure, classloader_symbol, class_symbol, filepath_symbol, method_symbol, signature_symbol);
            }
          }
        } else if (is_class_line(line)) {
          if (classloader_symbol == NULL) {
            valid = false;
            if (PrintFDOErrorInfo) {
              tty->print_cr("FDO: Precondition of class is wrong");
            }
          } else if (is_class_end(line)) {
            class_symbol = NULL;
            filepath_symbol = NULL;
            continue;
          } else {
            read_class(&class_symbol, &filepath_symbol, line, tmp, &valid, max_length);
          }
        } else {
          if (is_classloader_end(line)) {
            classloader_symbol = NULL;
          } else {
            classloader_symbol = read_classloader(line, tmp, &valid, max_length);
          }
        }
      }
      if (valid == false) {
        if (PrintFDOErrorInfo) {
          tty->print_cr("FDO: error line %s", line);
        }
        break;
      }
    } // end of while
    fclose(f);
  }
}

FDOPolicyDictionary::FDOPolicyDictionary(unsigned int size)
  : Hashtable<FDOPolicy*, mtCompiler>(size, sizeof(FDOPolicyEntry)) {
}

FDOPolicyDictionary::~FDOPolicyDictionary() {
  for (int i; i < table_size(); i++) {
    FDOPolicyEntry* p = bucket(i);
    FDOPolicyEntry* next = NULL;
    while (p != NULL) {
      next = p->next();
      delete p->literal();
      p = next;
    }
  }
  free_buckets();
}
FDOPolicyEntry* FDOPolicyDictionary::new_entry(unsigned int hash, FDOPolicy* policy) {
  FDOPolicyEntry* entry = (FDOPolicyEntry*)Hashtable<FDOPolicy*, mtCompiler>::new_entry(hash, policy);
  return entry;
}
FDOPolicyEntry* FDOPolicyDictionary::add_policy(unsigned int policy_bits,
  Symbol* class_loader,  Symbol* class_name, Symbol* file_path, Symbol* method, Symbol* signature) {
  unsigned int hash = compute_hash(class_name);
  int index = hash_to_index(hash);
  FDOPolicyEntry* entry = find_entry(hash, class_loader, class_name, file_path, method, signature);
  if (entry != NULL) {
    entry->literal()->update_policy(entry->literal()->policy() | policy_bits);
    return entry;
  }
  FDOPolicy* policy = new FDOPolicy(class_loader, class_name, file_path, method, signature);
  policy->update_policy(policy_bits);
  entry = new_entry(hash, policy);
  add_entry(index, entry);
  return entry;
}

FDOPolicyEntry* FDOPolicyDictionary::find_entry(unsigned int hash, FDOPolicy* policy)
{
  int index = hash_to_index(hash);
  for (FDOPolicyEntry* p = bucket(index); p != NULL; p = p->next()) {
    if (p->literal() && p->literal()->match(policy)) {
      return p;
    }
  }
  return NULL;
}
FDOPolicyEntry* FDOPolicyDictionary::find_entry(unsigned int hash, Symbol* class_loader,
    Symbol* class_name, Symbol* file_path, Symbol* method, Symbol* signature)
{
  int index = hash_to_index(hash);
  for (FDOPolicyEntry* p = bucket(index); p != NULL; p = p->next()) {
    if (p->literal() && p->literal()->match(class_loader, class_name, file_path, method, signature)) {
      return p;
    }
  }
  return NULL;
}

